# 设计模式--面向对象设计
- 低层思维
>1. 语言构造
>2. 编译转换
>3. 内存模型
>4. 运行时机制
- 抽象思维
>1. 面向对象
>2. 组件封装
>3. 设计模式
>4. 架构模式
- 三大面向对象机制
>1. 封装，隐藏内部实现
>2. 继承，复用现有代码
>3. 多态，改写对象行为
- 复杂问题产生的根本原因
> 变化
- 解决复杂性问题思路
>1. 分解
>2. 抽象
- 软件设计的目标
> 复用
## 面向对象设计原则
1. 依赖倒置原则(DIP)
> 高层模块(稳定)不应该依赖低层模块(变化)，二者都应该依赖于抽象(稳定)。
> 抽象(稳定)不应该依赖实现细节(变化)，实现细节应该依赖于抽象(稳定)。
2. 开放封闭原则(OCP)
> 对扩展开放，对更改封闭。
> 类模块应该是可扩展的，但是不可修改。
3. 单一职责原则(SRP)
> 一个类应该仅有一个引起它变化的原因。
> 变化的方向隐含着类的职责。
4. Liskov 替换原则(LSP)
> 子类必须能够替换它们的基类(IS-A)。
> 继承表达类型抽象。
5. 接口隔离原则(ISP)
> 不应该强迫客户程序依赖它们不用的方法。
> 接口应该小而完备。
6. 优先使用对象组合，而不是类继承
> 类继承通常为"白箱复用"，对象组合通常为"黑箱复用"。
> 继承在某种程度上破坏了封装性，子类父类耦合度高。
> 而对象组合则是要求被组合的对象具有良好定义的接口的接口，耦合度低。
7. 封装变化点
> 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。
8. 针对接口编程，而不是针对实现编程
> 不将变量类型声明为某个特定类型的具体类，而是声明为某个接口。
> 客户程序无需知道对象的具体类型，只需要知道对象所具有的接口。
> 减少系统中各部分的依赖关系，从而实现”高内聚，松耦合“的类型设计方案。
- 面向接口设计---接口标准化！

- **将设计原则提升为设计经验**

设计习语 Design Idioms
 > Design Idioms 描述与特定编程语言相关的低层模型，技巧，惯用法。

 设计模式 Design Patterns
 > Design Patterns 主要描述的是"类与相互通信的对象之间的组织关系"，包括它们的角色、职责、协作方式等方面。

 架构模式 Architectural Patterns
 > Architectural Patterns 描述系统中与基本结构组织关系密切的高层模块，包括子系统划分，职责，以及如何组织它们之间关系的规则。

 ## 模式介绍
 - GOF-23 模式分类
目的来看:
>1. 创建型模式：作用于对象的创建，将对象的创建与使用分离。其中囊括了单例、原型、工厂方法、抽象工厂、建造者5种创建型模式。
>2. 结构型模式：将类或对象按某种布局组成更大的结构，其中以代理、适配器、桥接、装饰、外观、享元、组合 7 种结构型模式为主。 
>3. 行为型模式：作用于类或对象之间相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。主要包含了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。

范围来看:
>1. 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，在编译时刻便确定下来了。工厂方法、（类）适配器、模板方法、解释器均属于该模式。
>2. 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。除了以上 4 种，其他的都是对象模式。

- **重构获得模式**(refactoring to patterns)

c++重构关键技法：
> 静态->动态
> 早绑定->晚绑定  由子类静态调用父类转为父类动态调用子类
> 继承->组合
> 编译时依赖->运行时依赖
> 紧耦合->松耦合

- "组件协作"模式:
通过晚绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式。

典型模式：
> Template Method
> Strategy
> Observer/Event

**Template Method**
> 定义一个操作中的算法骨架(稳定)，而将算法的一些步骤(变化)延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
> 变化的步骤通常声明为 ***protected*** 以供子类 override。

- 前者如***library 开发人员***，后者如 ***application 开发人员***

**Strategy**
> 定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。

**Observer/Event**(发布Publish--订阅Subscribe)
> 多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。

- "单一责任"模式
在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划分责任。

典型模式：
> Decorator
> Bridge

**Decorator**
> 动态的给对象增加一些职责，即增加其额外的功能。
> 解决主体类多方向的扩展。

**Bridge**
> 将抽象与实现分离，使它们可以独立变化。
> 它是用**组合**关系代替**继承**关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。

- "对象创建"模式
通过 "对象创建" 绕开 new，来避免对象创建(new)过程中所导致的紧耦合(依赖具体类)，从而支持对象创建的稳定。它是接口抽象后之后的第一步工作。

典型模式：
> Factory Method
> Astract Factory
> Prototype
> Builder

**Factory Method**
> 定义一个用于创建产品的接口，由子类决定生产什么产品。

**Astract Factory**
> 提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
> 针对一系列相互依赖的对象抽象。

**Prototype**
> 将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。

**Builder**建造者模式
> 将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。

- "对象性能"模式
面向对象很好的解决了"对象"抽象的问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。

典型模式：
> Sigleton
> Flyweight

**Sigleton**单例模式
> 某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。

**Flyweight**享元模式
> 运用共享技术来有效地支持大量细粒度对象的复用。
